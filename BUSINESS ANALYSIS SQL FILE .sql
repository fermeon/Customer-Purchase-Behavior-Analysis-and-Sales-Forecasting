USE BUSINESS;
-- 1. Customer Segmentation Analysis
-- 1.1: Count Customers by Gender
SELECT Gender, COUNT(*) AS Total_Customers
FROM CUSTOMERSDATA
GROUP BY Gender;

-- 1.2: Count Customers by Location
SELECT Location, COUNT(*) AS Total_Customers
FROM CUSTOMERSDATA
GROUP BY Location
ORDER BY Total_Customers DESC;

-- 1.3: Average Tenure of Customers
SELECT AVG(Tenure_Months) AS Average_Tenure
FROM CUSTOMERSDATA;

-- 2. Sales Trends Analysis
-- 2.1: Total Sales per Month
SELECT DATE_FORMAT(Transaction_Date, '%Y-%m') AS Sale_Month, SUM(Avg_Price) AS Total_Sales
FROM SALES
GROUP BY Sale_Month
ORDER BY Sale_Month;

-- 2.2: Top-Selling Products
SELECT Product_Description, SUM(Quantity) AS Total_Quantity_Sold
FROM SALES
GROUP BY Product_Description
ORDER BY Total_Quantity_Sold DESC
LIMIT 10;

-- 2.3: Sales Distribution by Location
SELECT Location, SUM(Avg_Price) AS Total_Sales
FROM SALES S
JOIN CUSTOMERSDATA C ON S.CustomerID = C.CustomerID
GROUP BY Location
ORDER BY Total_Sales DESC;

-- 3. Impact of Discounts
-- 3.1: Sales During Discount Periods
SELECT 
    D.Product_Category, 
    D.Discount_pct, 
    IFNULL(SUM(S.Avg_Price), 0) AS Total_Sales
FROM 
    DISCOUNT D
LEFT JOIN 
    SALES S ON S.Product_Category = D.Product_Category 
    AND DATE_FORMAT(S.Transaction_Date, '%M') = D.Month
GROUP BY 
    D.Product_Category, D.Discount_pct
ORDER BY 
    Total_Sales DESC;




-- 3.2: Average Discounted Sale Amount
SELECT AVG(S.Avg_Price * (1 - D.Discount_pct / 100)) AS Average_Discounted_Sale
FROM SALES S
JOIN DISCOUNT D ON S.Product_Category = D.Product_Category 
AND DATE_FORMAT(S.Transaction_Date, '%M') = D.Month;

-- 4. Marketing Spend Impact Analysis
-- 4.1: Correlation Between Marketing Spend and Sales
SELECT M.Date, M.Offline_Spend, M.Online_Spend, IFNULL(SUM(S.Avg_Price), 0) AS Total_Sales
FROM MARKETING_SPEND M
LEFT JOIN SALES S ON DATE(M.Date) = DATE(S.Transaction_Date)
GROUP BY M.Date, M.Offline_Spend, M.Online_Spend
ORDER BY M.Date;

-- 4.2: Sales Performance Before and After Major Marketing Campaigns
SELECT M.Date, SUM(S.Avg_Price) AS Total_Sales
FROM SALES S
JOIN MARKETING_SPEND M ON DATE(M.Date) = DATE(S.Transaction_Date)
WHERE M.Offline_Spend > (SELECT AVG(Offline_Spend) FROM MARKETING_SPEND) OR
      M.Online_Spend > (SELECT AVG(Online_Spend) FROM MARKETING_SPEND)
GROUP BY M.Date
ORDER BY M.Date;

-- 5. Tax and Profitability Analysis
-- 5.1: Sales Tax Calculation
SELECT S.Product_Description, SUM(S.Avg_Price) AS Total_Sales, 
       SUM(S.Avg_Price * T.GST / 100) AS Total_Tax
FROM SALES S
JOIN TAX T ON S.Product_Category = T.Product_Category
GROUP BY S.Product_Description;

-- 5.2: Profit After Tax
SELECT S.Product_Description, SUM(S.Avg_Price - (S.Avg_Price * T.GST / 100)) AS Profit_After_Tax
FROM SALES S
JOIN TAX T ON S.Product_Category = T.Product_Category
GROUP BY S.Product_Description
ORDER BY Profit_After_Tax DESC;
SELECT 
    Product_Category,
    Location, 
    DATE_FORMAT(Transaction_Date, '%Y-%m') AS Sale_Month,
    SUM(Avg_Price) AS Total_Sales
FROM SALES
JOIN CUSTOMERSDATA ON SALES.CustomerID = CUSTOMERSDATA.CustomerID
GROUP BY Product_Category, Location, DATE_FORMAT(Transaction_Date, '%Y-%m')
UNION ALL
SELECT
    Product_Category,
    'All Locations',
    DATE_FORMAT(Transaction_Date, '%Y-%m'),
    SUM(Avg_Price)
FROM SALES
JOIN CUSTOMERSDATA ON SALES.CustomerID = CUSTOMERSDATA.CustomerID
GROUP BY Product_Category, DATE_FORMAT(Transaction_Date, '%Y-%m')
UNION ALL
SELECT
    'All Products',
    Location,
    DATE_FORMAT(Transaction_Date, '%Y-%m'),
    SUM(Avg_Price)
FROM SALES
JOIN CUSTOMERSDATA ON SALES.CustomerID = CUSTOMERSDATA.CustomerID
GROUP BY Location, DATE_FORMAT(Transaction_Date, '%Y-%m')
UNION ALL
SELECT
    'All Products',
    'All Locations',
    DATE_FORMAT(Transaction_Date, '%Y-%m'),
    SUM(Avg_Price)
FROM SALES
JOIN CUSTOMERSDATA ON SALES.CustomerID = CUSTOMERSDATA.CustomerID
GROUP BY DATE_FORMAT(Transaction_Date, '%Y-%m')
ORDER BY Product_Category, Location, Sale_Month;

-- Detecting Sudden Changes in Time-Series Data using Window Functions:
SELECT
    DATE_FORMAT(Transaction_Date, '%Y-%m') AS Sale_Month,
    SUM(Avg_Price) AS Total_Sales,
    SUM(Avg_Price) - LAG(SUM(Avg_Price), 1) OVER (ORDER BY DATE_FORMAT(Transaction_Date, '%Y-%m')) AS Sales_Change,
    CASE
        WHEN ABS(SUM(Avg_Price) - LAG(SUM(Avg_Price), 1) OVER (ORDER BY DATE_FORMAT(Transaction_Date, '%Y-%m'))) > 2 * SQRT(VARIANCE(SUM(Avg_Price)) OVER (ORDER BY DATE_FORMAT(Transaction_Date, '%Y-%m'))) THEN 'Anomaly'
        ELSE 'Normal'
    END AS Status
FROM SALES
GROUP BY Sale_Month
ORDER BY Sale_Month;

-- Step 1: Calculate Lifetime Value (LTV) for Each Customer
-- LTV is the total revenue generated by each customer

WITH CustomerLTV AS (
    SELECT
        CustomerID,
        SUM(Avg_Price * Quantity) AS LifetimeValue
    FROM
        SALES
    GROUP BY
        CustomerID
),

-- Step 2: Rank Customers Based on LTV
-- Using DENSE_RANK() to rank customers by LTV in descending order

RankedCustomers AS (
    SELECT
        CustomerID,
        LifetimeValue,
        DENSE_RANK() OVER (ORDER BY LifetimeValue DESC) AS LTV_Rank
    FROM
        CustomerLTV
),

-- Step 3: Segment Customers into High-Value and Low-Value Groups
-- Customers ranked in the top 10 are considered high-value

SegmentedCustomers AS (
    SELECT
        rc.CustomerID,
        rc.LifetimeValue,
        rc.LTV_Rank,
        CASE
            WHEN rc.LTV_Rank <= 10 THEN 'High-Value'
            ELSE 'Low-Value'
        END AS CustomerSegment
    FROM
        RankedCustomers rc
),

-- Step 4: Forecast Future LTV (Optional, basic example using moving average)
-- This step forecasts LTV based on average spend per period

ForecastedLTV AS (
    SELECT
        CustomerID,
        AVG(LifetimeValue) AS AverageLTV,
        AVG(LifetimeValue) * 6 AS PredictedLTV -- Assuming a forecast for 6 future periods
    FROM
        (SELECT
            CustomerID,
            DATE_FORMAT(Transaction_Date, '%Y-%m') AS Period,
            SUM(Avg_Price * Quantity) AS LifetimeValue
        FROM
            SALES
        GROUP BY
            CustomerID, Period) AS PeriodicLTVTable
    GROUP BY
        CustomerID
)

-- Final Output: Combine all data
-- This output includes the original LTV, rank, segment, and predicted future LTV for each customer

SELECT
    sc.CustomerID,
    sc.LifetimeValue,
    sc.LTV_Rank,
    sc.CustomerSegment,
    fl.AverageLTV,
    fl.PredictedLTV
FROM
    SegmentedCustomers sc
LEFT JOIN
    ForecastedLTV fl ON sc.CustomerID = fl.CustomerID
ORDER BY
    sc.LTV_Rank;

 -- CUSTOMER RETENTION 
 WITH Monthly_Customers AS (
    SELECT DISTINCT
        DATE_FORMAT(Transaction_Date, '%Y-%m') AS Month,
        CustomerID
    FROM
        Sales
    WHERE
        Transaction_Date BETWEEN '2018-12-01' AND '2019-12-31'
),
CustomerCounts AS (
    SELECT 
        Month,
        COUNT(DISTINCT CustomerID) AS CustomerCount
    FROM 
        Monthly_Customers
    GROUP BY 
        Month
),
MonthPairs AS (
    SELECT 
        Month AS Current_Month,
        LEAD(Month) OVER (ORDER BY Month) AS Next_Month
    FROM CustomerCounts
)
SELECT
    mp.Current_Month,
    c1.CustomerCount AS Current_Month_Customers,
    mp.Next_Month,
    c2.CustomerCount AS Next_Month_Customers,
    COUNT(DISTINCT CASE WHEN m2.CustomerID IS NOT NULL THEN m1.CustomerID END) AS Retained_Customers,
    CASE 
        WHEN c1.CustomerCount > 0 THEN 
            ROUND((COUNT(DISTINCT CASE WHEN m2.CustomerID IS NOT NULL THEN m1.CustomerID END) / c1.CustomerCount) * 100, 2)
        ELSE 0
    END AS Retention_Rate
FROM
    MonthPairs mp
JOIN
    CustomerCounts c1 ON mp.Current_Month = c1.Month
LEFT JOIN
    CustomerCounts c2 ON mp.Next_Month = c2.Month
LEFT JOIN
    Monthly_Customers m1 ON m1.Month = mp.Current_Month
LEFT JOIN
    Monthly_Customers m2 ON m2.Month = mp.Next_Month AND m1.CustomerID = m2.CustomerID
WHERE
    mp.Current_Month BETWEEN '2019-01' AND '2019-12'
GROUP BY
    mp.Current_Month, c1.CustomerCount, mp.Next_Month, c2.CustomerCount
ORDER BY
    mp.Current_Month;
    
